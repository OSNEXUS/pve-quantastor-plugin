--- ZFSPlugin.8.4.0.pm	2025-11-21 23:21:50.455050022 +0000
+++ ZFSPlugin.8.4.0_new.pm	2025-11-21 23:21:50.455050022 +0000
@@ -11,6 +11,7 @@
 use base qw(PVE::Storage::ZFSPoolPlugin);
 use PVE::Storage::LunCmd::Comstar;
 use PVE::Storage::LunCmd::Istgt;
+use PVE::Storage::LunCmd::QuantaStorPlugin;
 use PVE::Storage::LunCmd::Iet;
 use PVE::Storage::LunCmd::LIO;
 
@@ -32,7 +33,7 @@
 my $zfs_unknown_scsi_provider = sub {
     my ($provider) = @_;
 
-    die "$provider: unknown iscsi provider. Available [comstar, istgt, iet, LIO]";
+    die "$provider: unknown iscsi provider. Available [comstar, istgt, iet, LIO, quantastor]";
 };
 
 my $zfs_get_base = sub {
@@ -46,6 +47,8 @@
         return PVE::Storage::LunCmd::Iet::get_base;
     } elsif ($scfg->{iscsiprovider} eq 'LIO') {
         return PVE::Storage::LunCmd::LIO::get_base;
+    } elsif ($scfg->{iscsiprovider} eq 'quantastor') {
+        return PVE::Storage::LunCmd::QuantaStorPlugin::get_base;
     } else {
         $zfs_unknown_scsi_provider->($scfg->{iscsiprovider});
     }
@@ -68,11 +71,19 @@
             $msg = PVE::Storage::LunCmd::Iet::run_lun_command($scfg, $timeout, $method, @params);
         } elsif ($scfg->{iscsiprovider} eq 'LIO') {
             $msg = PVE::Storage::LunCmd::LIO::run_lun_command($scfg, $timeout, $method, @params);
+        } elsif ($scfg->{iscsiprovider} eq 'quantastor') {
+            $msg = PVE::Storage::LunCmd::QuantaStorPlugin::run_lun_command($scfg, $timeout, $method, @params);
         } else {
             $zfs_unknown_scsi_provider->($scfg->{iscsiprovider});
         }
     } else {
 
+        if ($scfg->{iscsiprovider} eq 'quantastor') {
+            if ($method eq 'get') {
+                return PVE::Storage::LunCmd::QuantaStorPlugin::qs_zfs_get_command($scfg, $timeout, $method, @params);
+            }
+        }
+
 	my $target = 'root@' . $scfg->{portal};
 
 	my $cmd = [@ssh_cmd, '-i', "$id_rsa_path/$scfg->{portal}_id_rsa", $target];
@@ -92,7 +103,6 @@
 
         run_command($cmd, outfunc => $output, timeout => $timeout);
     }
-
     return $msg;
 }
 
@@ -130,6 +140,15 @@
     $class->zfs_request($scfg, undef, 'delete_lu', $guid);
 }
 
+sub zfs_create_zvol {
+    my ($class, $scfg, $zvol, $size) = @_;
+    if ($scfg->{iscsiprovider} eq 'quantastor') {
+        PVE::Storage::LunCmd::QuantaStorPlugin::qs_zfs_create_zvol($scfg, $zvol, $size);
+        return;
+    }
+    $class->SUPER::zfs_create_zvol($scfg, $zvol, $size);
+}
+
 sub zfs_create_lu {
     my ($class, $scfg, $zvol) = @_;
 
@@ -204,6 +223,22 @@
 	    description => "target portal group for Linux LIO targets",
 	    type => 'string',
 	},
+    qs_user => {
+	    description => "QuantaStor API username",
+	    type => 'string',
+	},
+    qs_password => {
+	    description => "QuantaStor API password",
+	    type => 'string',
+	},
+    qs_use_ssl => {
+	    description => "QuantaStor API access via SSL",
+	    type => 'string',
+	},
+    qs_apiv4_host => {
+	    description => "QuantaStor API host IPv4 address",
+	    type => 'string',
+	},
     };
 }
 
@@ -212,8 +247,8 @@
 	nodes => { optional => 1 },
 	disable => { optional => 1 },
 	portal => { fixed => 1 },
-	target => { fixed => 1 },
-	pool => { fixed => 1 },
+	target => { fixed => 0 },
+	pool => { fixed => 0 },
 	blocksize => { fixed => 1 },
 	iscsiprovider => { fixed => 1 },
 	nowritecache => { optional => 1 },
@@ -221,6 +256,10 @@
 	comstar_hg => { optional => 1 },
 	comstar_tg => { optional => 1 },
 	lio_tpg => { optional => 1 },
+    qs_user => { optional => 1 },
+    qs_password => { optional => 1 },
+    qs_use_ssl => { optional => 1 },
+    qs_apiv4_host => { optional => 1 },
 	content => { optional => 1 },
 	bwlimit => { optional => 1 },
     };
@@ -234,6 +273,10 @@
     die "direct access to snapshots not implemented"
 	if defined($snapname);
 
+    if ($scfg->{iscsiprovider} eq 'quantastor') {
+        return PVE::Storage::LunCmd::QuantaStorPlugin::qs_path($scfg, $volname, $storeid, $snapname);
+    }
+
     my ($vtype, $name, $vmid) = $class->parse_volname($volname);
 
     my $target = $scfg->{target};
@@ -255,6 +298,10 @@
     my ($vtype, $name, $vmid, $basename, $basevmid, $isBase) =
         $class->parse_volname($volname);
 
+    if ($scfg->{iscsiprovider} eq 'quantastor') {
+        return PVE::Storage::LunCmd::QuantaStorPlugin::qs_create_base($storeid, $scfg, $basename, $name);
+    }
+
     die "create_base not possible with base image\n" if $isBase;
 
     my $newname = $name;
@@ -278,6 +325,10 @@
 sub clone_image {
     my ($class, $scfg, $storeid, $volname, $vmid, $snap) = @_;
 
+    if ($scfg->{iscsiprovider} eq 'quantastor') {
+        return PVE::Storage::LunCmd::QuantaStorPlugin::qs_clone_image($scfg, $storeid, $volname, $vmid, $snap);
+    }
+
     my $name = $class->SUPER::clone_image($scfg, $storeid, $volname, $vmid, $snap);
 
     # get ZFS dataset name from PVE volname
@@ -340,6 +391,10 @@
 
 sub volume_snapshot_delete {
     my ($class, $scfg, $storeid, $volname, $snap, $running) = @_;
+    if ($scfg->{iscsiprovider} eq 'quantastor') {
+        PVE::Storage::LunCmd::QuantaStorPlugin::qs_volume_snapshot_delete($scfg, $storeid, $volname, $snap, $running);
+        return;
+    }
 
     $volname = ($class->parse_volname($volname))[1];
 
@@ -348,6 +403,10 @@
 
 sub volume_snapshot_rollback {
     my ($class, $scfg, $storeid, $volname, $snap) = @_;
+    if ($scfg->{iscsiprovider} eq 'quantastor') {
+        PVE::Storage::LunCmd::QuantaStorPlugin::qs_volume_snapshot_rollback($scfg, $storeid, $volname, $snap);
+        return;
+    }
 
     $volname = ($class->parse_volname($volname))[1];
 
@@ -394,6 +453,9 @@
 
 sub activate_storage {
     my ($class, $storeid, $scfg, $cache) = @_;
+    if ($scfg->{iscsiprovider} eq 'quantastor') {
+        PVE::Storage::LunCmd::QuantaStorPlugin::activate_storage($class, $storeid, $scfg, $cache);
+    }
 
     return 1;
 }
@@ -420,4 +482,57 @@
     return 1;
 }
 
+# quantastor overrides
+sub list_images {
+    my ($class, $storeid, $scfg, $vmid, $vollist, $cache) = @_;
+    if ($scfg->{iscsiprovider} eq 'quantastor') {
+        return PVE::Storage::LunCmd::QuantaStorPlugin::qs_list_images($storeid, $scfg, $vmid, $vollist, $cache);
+    }
+
+    return $class->SUPER::list_images($storeid, $scfg, $vmid, $vollist, $cache);
+}
+
+sub zfs_delete_zvol {
+    my ($class, $scfg, $zvol) = @_;
+    if ($scfg->{iscsiprovider} eq 'quantastor') {
+        return PVE::Storage::LunCmd::QuantaStorPlugin::qs_zfs_delete_zvol($scfg, $zvol);
+    }
+
+    die $class->SUPER::zfs_delete_zvol($scfg, $zvol);
+}
+
+sub zfs_get_properties {
+    my ($class, $scfg, $properties, $dataset, $timeout) = @_;
+    if ($scfg->{iscsiprovider} eq 'quantastor') {
+        my $tmp = $dataset;
+        if ($tmp =~ m{^([^/]+)/([^/]+)$}) {
+            # Pool + Volume ID is the correct path for QuantaStor zvols
+            my $pool = $1;
+            my $vol  = $2;
+            my $vol_id = PVE::Storage::LunCmd::QuantaStorPlugin::qs_get_zvol_id_by_name($scfg, $vol, $pool);
+            $dataset = "$pool/$vol_id";
+        }
+    }
+
+    return $class->SUPER::zfs_get_properties($scfg, $properties, $dataset, $timeout);
+}
+
+sub volume_rollback_is_possible {
+    my ($class, $scfg, $storeid, $volname, $snap, $blockers) = @_;
+    if ($scfg->{iscsiprovider} eq 'quantastor') {
+        return PVE::Storage::LunCmd::QuantaStorPlugin::qs_volume_rollback_is_possible($scfg, $storeid, $volname, $snap, $blockers);
+    }
+
+    return $class->SUPER::volume_rollback_is_possible($scfg, $storeid, $volname, $snap, $blockers);
+}
+
+sub volume_snapshot {
+    my ($class, $scfg, $storeid, $volname, $snap) = @_;
+    if ($scfg->{iscsiprovider} eq 'quantastor') {
+        PVE::Storage::LunCmd::QuantaStorPlugin::qs_volume_snapshot($scfg, $storeid, $volname, $snap);
+        return;
+    }
+    $class->SUPER::volume_snapshot($scfg, $storeid, $volname, $snap);
+}
+
 1;
