--- ZFSPlugin.9.1.1.pm	2025-11-20 19:08:06.952928914 +0000
+++ ZFSPlugin.9.1.1_new.pm	2025-11-20 19:22:06.002075831 +0000
@@ -12,6 +12,7 @@
 use base qw(PVE::Storage::ZFSPoolPlugin);
 use PVE::Storage::LunCmd::Comstar;
 use PVE::Storage::LunCmd::Istgt;
++use PVE::Storage::LunCmd::QuantaStorPlugin;
 use PVE::Storage::LunCmd::Iet;
 use PVE::Storage::LunCmd::LIO;
 
@@ -32,7 +33,7 @@
 my $zfs_unknown_scsi_provider = sub {
     my ($provider) = @_;
 
-    die "$provider: unknown iscsi provider. Available [comstar, istgt, iet, LIO]";
+    die "$provider: unknown iscsi provider. Available [comstar, istgt, iet, LIO, quantastor]";
 };
 
 my $zfs_get_base = sub {
@@ -46,6 +47,8 @@
         return PVE::Storage::LunCmd::Iet::get_base($scfg);
     } elsif ($scfg->{iscsiprovider} eq 'LIO') {
         return PVE::Storage::LunCmd::LIO::get_base($scfg);
+    } elsif ($scfg->{iscsiprovider} eq 'quantastor') {
+        return PVE::Storage::LunCmd::QuantaStorPlugin::get_base($scfg);
     } else {
         $zfs_unknown_scsi_provider->($scfg->{iscsiprovider});
     }
@@ -69,11 +72,17 @@
             $msg = PVE::Storage::LunCmd::Iet::run_lun_command($scfg, $timeout, $method, @params);
         } elsif ($scfg->{iscsiprovider} eq 'LIO') {
             $msg = PVE::Storage::LunCmd::LIO::run_lun_command($scfg, $timeout, $method, @params);
+        } elsif ($scfg->{iscsiprovider} eq 'quantastor') {
+            $msg = PVE::Storage::LunCmd::QuantaStorPlugin::run_lun_command($scfg, $timeout, $method, @params);
         } else {
             $zfs_unknown_scsi_provider->($scfg->{iscsiprovider});
         }
     } else {
-
+        if ($scfg->{iscsiprovider} eq 'quantastor') {
+            if ($method eq 'get') {
+                return PVE::Storage::LunCmd::QuantaStorPlugin::qs_zfs_get_command($scfg, $timeout, $method, @params);
+            }
+        }
         my $target = 'root@' . $scfg->{portal};
 
         my $cmd = [@ssh_cmd, '-i', "$id_rsa_path/$scfg->{portal}_id_rsa", $target];
@@ -131,6 +140,15 @@
     $class->zfs_request($scfg, undef, 'delete_lu', $guid);
 }
 
+sub zfs_create_zvol {
+    my ($class, $scfg, $zvol, $size) = @_;
+    if ($scfg->{iscsiprovider} eq 'quantastor') {
+        PVE::Storage::LunCmd::QuantaStorPlugin::qs_zfs_create_zvol($scfg, $zvol, $size);
+        return;
+    }
+    $class->SUPER::zfs_create_zvol($scfg, $zvol, $size);
+}
+
 sub zfs_create_lu {
     my ($class, $scfg, $zvol) = @_;
 
@@ -211,6 +229,22 @@
             type => 'string',
             format => 'pve-storage-path',
         },
+        qs_user => {
+	        description => "QuantaStor API username",
+	        type => 'string',
+	    },
+        qs_password => {
+	        description => "QuantaStor API password",
+	        type => 'string',
+	    },
+        qs_use_ssl => {
+	        description => "QuantaStor API access via SSL",
+	        type => 'string',
+	    },
+        qs_apiv4_host => {
+	        description => "QuantaStor API host IPv4 address",
+	        type => 'string',
+	    },
     };
 }
 
@@ -219,8 +253,8 @@
         nodes => { optional => 1 },
         disable => { optional => 1 },
         portal => { fixed => 1 },
-        target => { fixed => 1 },
-        pool => { fixed => 1 },
+        target => { fixed => 0 },
+        pool => { fixed => 0 },
         blocksize => { fixed => 1 },
         iscsiprovider => { fixed => 1 },
         nowritecache => { optional => 1 },
@@ -228,6 +262,10 @@
         comstar_hg => { optional => 1 },
         comstar_tg => { optional => 1 },
         lio_tpg => { optional => 1 },
+        qs_user => { optional => 1 },
+        qs_password => { optional => 1 },
+        qs_use_ssl => { optional => 1 },
+        qs_apiv4_host => { optional => 1 },
         content => { optional => 1 },
         bwlimit => { optional => 1 },
         'zfs-base-path' => { optional => 1 },
@@ -282,6 +320,9 @@
 
     die "direct access to snapshots not implemented"
         if defined($snapname);
+    if ($scfg->{iscsiprovider} eq 'quantastor') {
+        return PVE::Storage::LunCmd::QuantaStorPlugin::qs_path($scfg, $volname, $storeid, $snapname);
+    }
 
     my ($vtype, $name, $vmid) = $class->parse_volname($volname);
 
@@ -322,6 +363,10 @@
 
     my ($vtype, $name, $vmid, $basename, $basevmid, $isBase) = $class->parse_volname($volname);
 
+    if ($scfg->{iscsiprovider} eq 'quantastor') {
+        return PVE::Storage::LunCmd::QuantaStorPlugin::qs_create_base($storeid, $scfg, $basename, $name);
+    }
+
     die "create_base not possible with base image\n" if $isBase;
 
     my $newname = $name;
@@ -343,6 +388,10 @@
 sub clone_image {
     my ($class, $scfg, $storeid, $volname, $vmid, $snap) = @_;
 
+    if ($scfg->{iscsiprovider} eq 'quantastor') {
+        return PVE::Storage::LunCmd::QuantaStorPlugin::qs_clone_image($scfg, $storeid, $volname, $vmid, $snap);
+    }
+
     my $name = $class->SUPER::clone_image($scfg, $storeid, $volname, $vmid, $snap);
 
     # get ZFS dataset name from PVE volname
@@ -405,6 +454,10 @@
 
 sub volume_snapshot_delete {
     my ($class, $scfg, $storeid, $volname, $snap, $running) = @_;
+    if ($scfg->{iscsiprovider} eq 'quantastor') {
+        PVE::Storage::LunCmd::QuantaStorPlugin::qs_volume_snapshot_delete($scfg, $storeid, $volname, $snap, $running);
+        return;
+    }
 
     $volname = ($class->parse_volname($volname))[1];
 
@@ -413,6 +466,10 @@
 
 sub volume_snapshot_rollback {
     my ($class, $scfg, $storeid, $volname, $snap) = @_;
+    if ($scfg->{iscsiprovider} eq 'quantastor') {
+        PVE::Storage::LunCmd::QuantaStorPlugin::qs_volume_snapshot_rollback($scfg, $storeid, $volname, $snap);
+        return;
+    }
 
     $volname = ($class->parse_volname($volname))[1];
 
@@ -425,6 +482,15 @@
     $class->zfs_add_lun_mapping_entry($scfg, $volname);
 }
 
+sub volume_snapshot {
+    my ($class, $scfg, $storeid, $volname, $snap) = @_;
+    if ($scfg->{iscsiprovider} eq 'quantastor') {
+        PVE::Storage::LunCmd::QuantaStorPlugin::qs_volume_snapshot($scfg, $storeid, $volname, $snap);
+        return;
+    }
+    $class->SUPER::volume_snapshot($scfg, $storeid, $volname, $snap);
+}
+
 sub storage_can_replicate {
     my ($class, $scfg, $storeid, $format) = @_;
 
@@ -458,6 +524,9 @@
 
 sub activate_storage {
     my ($class, $storeid, $scfg, $cache) = @_;
+    if ($scfg->{iscsiprovider} eq 'quantastor') {
+        PVE::Storage::LunCmd::QuantaStorPlugin::activate_storage($class, $storeid, $scfg, $cache);
+    }
 
     return 1;
 }
@@ -484,4 +553,57 @@
     return 1;
 }
 
+# quantastor overrides
+sub list_images {
+    my ($class, $storeid, $scfg, $vmid, $vollist, $cache) = @_;
+    if ($scfg->{iscsiprovider} eq 'quantastor') {
+        return PVE::Storage::LunCmd::QuantaStorPlugin::qs_list_images($storeid, $scfg, $vmid, $vollist, $cache);
+    }
+
+    return $class->SUPER::list_images($storeid, $scfg, $vmid, $vollist, $cache);
+}
+
+sub zfs_delete_zvol {
+    my ($class, $scfg, $zvol) = @_;
+    if ($scfg->{iscsiprovider} eq 'quantastor') {
+        return PVE::Storage::LunCmd::QuantaStorPlugin::qs_zfs_delete_zvol($scfg, $zvol);
+    }
+
+    die $class->SUPER::zfs_delete_zvol($scfg, $zvol);
+}
+
+sub zfs_get_properties {
+    my ($class, $scfg, $properties, $dataset, $timeout) = @_;
+    if ($scfg->{iscsiprovider} eq 'quantastor') {
+        my $tmp = $dataset;
+        if ($tmp =~ m{^([^/]+)/([^/]+)$}) {
+            # Pool + Volume ID is the correct path for QuantaStor zvols
+            my $pool = $1;
+            my $vol  = $2;
+            my $vol_id = PVE::Storage::LunCmd::QuantaStorPlugin::qs_get_zvol_id_by_name($scfg, $vol, $pool);
+            $dataset = "$pool/$vol_id";
+        }
+    }
+
+    return $class->SUPER::zfs_get_properties($scfg, $properties, $dataset, $timeout);
+}
+
+sub volume_rollback_is_possible {
+    my ($class, $scfg, $storeid, $volname, $snap, $blockers) = @_;
+    if ($scfg->{iscsiprovider} eq 'quantastor') {
+        return PVE::Storage::LunCmd::QuantaStorPlugin::qs_volume_rollback_is_possible($scfg, $storeid, $volname, $snap, $blockers);
+    }
+
+    return $class->SUPER::volume_rollback_is_possible($scfg, $storeid, $volname, $snap, $blockers);
+}
+
+sub volume_snapshot {
+    my ($class, $scfg, $storeid, $volname, $snap) = @_;
+    if ($scfg->{iscsiprovider} eq 'quantastor') {
+        PVE::Storage::LunCmd::QuantaStorPlugin::qs_volume_snapshot($scfg, $storeid, $volname, $snap);
+        return;
+    }
+    $class->SUPER::volume_snapshot($scfg, $storeid, $volname, $snap);
+}
+
 1;
